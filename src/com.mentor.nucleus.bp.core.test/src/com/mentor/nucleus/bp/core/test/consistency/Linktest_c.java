package com.mentor.nucleus.bp.core.test.consistency;
//====================================================================
//
// File:      com.mentor.nucleus.bp.core.test.consistency.Linktest_c.java
//
// WARNING: Do not edit this generated file
// Generated by ../MC-Java/java.arc, $Revision: 1.111 $
//
// (c) Copyright 2005-2014 by Mentor Graphics Corp.  All rights reserved.
//
//====================================================================

import com.mentor.nucleus.bp.core.*;
import com.mentor.nucleus.bp.core.test.CoreTestPlugin;
import java.util.*;
import java.lang.reflect.*;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Path;
import com.mentor.nucleus.bp.core.util.PersistenceUtil;
import org.eclipse.core.runtime.NullProgressMonitor;
import com.mentor.nucleus.bp.core.ui.marker.UmlProblem;
import com.mentor.nucleus.bp.core.common.*;
abstract class EV_LINKTEST extends genericEvent_c {
	public abstract int getEvtcode();
}

public class Linktest_c extends NonRootModelElement
		implements
			IAdaptable,
			Cloneable {
	// Public Constructors
	public Linktest_c(ModelRoot modelRoot, int p_m_llsid, int p_m_lrsid) {
		super(modelRoot);
		m_llsid = p_m_llsid;
		m_lrsid = p_m_lrsid;

		Object[] key = {new UUID(0, new Long(m_llsid)),
				new UUID(0, new Long(m_lrsid))};
		addInstanceToMap(key);
	}
	static public Linktest_c createProxy(ModelRoot modelRoot, int p_m_llsid,
			int p_m_lrsid, String p_contentPath, IPath p_localPath) {
		ModelRoot resolvedModelRoot = ModelRoot.findModelRoot(modelRoot,
				p_contentPath, p_localPath);
		// if a model root was not resolved it is most likely
		// due to a missing file of the proxy, defualt back to
		// the original model root
		if (resolvedModelRoot != null)
			modelRoot = resolvedModelRoot;
		InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);
		Linktest_c new_inst = null;
		synchronized (instances) {
			Object[] key = {new UUID(0, new Long(p_m_llsid)),
					new UUID(0, new Long(p_m_lrsid))};
			new_inst = (Linktest_c) instances.get(key);
		}
		String contentPath = PersistenceUtil.resolveRelativePath(p_localPath,
				new Path(p_contentPath));
		if (modelRoot.isNewCompareRoot()) {
			// for comparisons we do not want to change
			// the content path
			contentPath = p_contentPath;
		}
		if (new_inst != null && !modelRoot.isCompareRoot()) {
			PersistableModelComponent pmc = new_inst.getPersistableComponent();
			if (pmc == null) {
				// dangling reference, redo this instance
				new_inst.batchUnrelate();
				new_inst.m_llsid = p_m_llsid;
				new_inst.m_lrsid = p_m_lrsid;

			}
		}
		if (new_inst == null) {
			// there is no instance matching the id, create a proxy
			// if the resource doesn't exist then this will be a dangling reference
			new_inst = new Linktest_c(modelRoot, p_m_llsid, p_m_lrsid);
			new_inst.m_contentPath = contentPath;
		}
		return new_inst;
	}

	static public Linktest_c resolveInstance(ModelRoot modelRoot,
			int p_m_llsid, int p_m_lrsid) {
		InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);
		Linktest_c source = null;
		synchronized (instances) {
			Object[] key = {new UUID(0, new Long(p_m_llsid)),
					new UUID(0, new Long(p_m_lrsid))};
			source = (Linktest_c) instances.get(key);
			if (source != null && !modelRoot.isCompareRoot()) {
				source.convertFromProxy();
				source.batchUnrelate();
				source.m_llsid = p_m_llsid;
				source.m_lrsid = p_m_lrsid;

				return source;
			}
		}
		// there is no instance matching the id
		Linktest_c new_inst = new Linktest_c(modelRoot, p_m_llsid, p_m_lrsid);
		return new_inst;
	}
	public Linktest_c(ModelRoot modelRoot) {
		super(modelRoot);
		Object[] key = {new UUID(0, new Long(m_llsid)),
				new UUID(0, new Long(m_lrsid))};
		addInstanceToMap(key);
	}

	public Object getInstanceKey() {
		Object[] key = {new UUID(0, new Long(m_llsid)),
				new UUID(0, new Long(m_lrsid))};
		return key;
	}

	public boolean setInstanceKey(UUID p_newKey) {

		boolean changed = false;
		// round p1
		// round p2
		// round p3
		// round p4
		// round p6
		// round p7
		// round p1
		// round p2
		// round p3
		// round p4
		// round p6
		// round p7
		return changed;
	}

	public boolean equals(Object elem) {
		if (!(elem instanceof Linktest_c)) {
			return false;
		}
		// check that the model-roots are the same
		if (((NonRootModelElement) elem).getModelRoot() != getModelRoot()
				&& !getModelRoot().isCompareRoot()) {
			return false;
		}

		return identityEquals(elem);
	}

	public boolean identityEquals(Object elem) {
		if (!(elem instanceof Linktest_c)) {
			return false;
		}

		Linktest_c me = (Linktest_c) elem;
		if (getLlsid() != ((Linktest_c) elem).getLlsid())
			return false;
		if (getLrsid() != ((Linktest_c) elem).getLrsid())
			return false;
		return true;
	}

	public boolean cachedIdentityEquals(Object elem) {
		if (!(elem instanceof Linktest_c)) {
			return false;
		}

		Linktest_c me = (Linktest_c) elem;
		if (getLlsidCachedValue() != ((Linktest_c) elem).getLlsidCachedValue())
			return false;
		if (getLrsidCachedValue() != ((Linktest_c) elem).getLrsidCachedValue())
			return false;
		return true;
	}

	// Attributes
	private int m_llsid;
	private int m_lrsid;

	// declare association references from this class

	// referring navigation

	Linkrightside_c Linkrightside;
	public void relateAcrossR2To(Linkrightside_c target) {
		relateAcrossR2To(target, true);
	}
	public void relateAcrossR2To(Linkrightside_c target, boolean notifyChanges) {
		if (target == null)
			return;

		if (target == Linkrightside)
			return; // already related

		if (Linkrightside != target) {

			Object oldKey = getInstanceKey();

			if (Linkrightside != null) {

				Linkrightside.clearBackPointerR2To(this);

				if (Boolean.valueOf(System.getenv("PTC_MCC_ENABLED")) == true) { //$NON-NLS-1$
					Consistency.log
							.println(
									ILogger.CONSISTENCY,
									"Linktest_c.relateAcrossR2To(Linkrightside_c target)",
									"Relate performed across R2 from linkTest to linkRightSide without unrelate of prior instance.");
				}
			}

			Linkrightside = target;
			m_lrsid = target.getLrsid();
			updateInstanceKey(oldKey, getInstanceKey());
			target.setBackPointerR2To(this);
			target.addRef();
			if (notifyChanges) {
				RelationshipChangeModelDelta change = new RelationshipChangeModelDelta(
						Modeleventnotification_c.DELTA_ELEMENT_RELATED, this,
						target, "2", "");
				Consistency.getDefaultInstance()
						.fireModelElementRelationChanged(change);
			}
		}
	}
	public void unrelateAcrossR2From(Linkrightside_c target) {
		unrelateAcrossR2From(target, true);
	}
	public void unrelateAcrossR2From(Linkrightside_c target,
			boolean notifyChanges) {
		if (target == null)
			return;

		if (Linkrightside == null)
			return; // already unrelated

		if (target != Linkrightside) {
			Exception e = new Exception();
			e.fillInStackTrace();
			CoreTestPlugin.logError(
					"Tried to unrelate from non-related instance across R2", e);
			return;
		}

		if (target != null) {
			target.clearBackPointerR2To(this);
		}

		if (Linkrightside != null) {

			m_lrsid = Linkrightside.getLrsid();
			Linkrightside = null;
			target.removeRef();
			if (notifyChanges) {
				RelationshipChangeModelDelta change = new RelationshipChangeModelDelta(
						Modeleventnotification_c.DELTA_ELEMENT_UNRELATED, this,
						target, "2", "");
				Consistency.getDefaultInstance()
						.fireModelElementRelationChanged(change);
			}
		}
	}

	// referring navigation

	Linkleftside_c Linkleftside;
	public void relateAcrossR2To(Linkleftside_c target) {
		relateAcrossR2To(target, true);
	}
	public void relateAcrossR2To(Linkleftside_c target, boolean notifyChanges) {
		if (target == null)
			return;

		if (target == Linkleftside)
			return; // already related

		if (Linkleftside != target) {

			Object oldKey = getInstanceKey();

			if (Linkleftside != null) {

				Linkleftside.clearBackPointerR2To(this);

				if (Boolean.valueOf(System.getenv("PTC_MCC_ENABLED")) == true) { //$NON-NLS-1$
					Consistency.log
							.println(
									ILogger.CONSISTENCY,
									"Linktest_c.relateAcrossR2To(Linkleftside_c target)",
									"Relate performed across R2 from linkTest to linkLeftSide without unrelate of prior instance.");
				}
			}

			Linkleftside = target;
			m_llsid = target.getLlsid();
			updateInstanceKey(oldKey, getInstanceKey());
			target.setBackPointerR2To(this);
			target.addRef();
			if (notifyChanges) {
				RelationshipChangeModelDelta change = new RelationshipChangeModelDelta(
						Modeleventnotification_c.DELTA_ELEMENT_RELATED, this,
						target, "2", "");
				Consistency.getDefaultInstance()
						.fireModelElementRelationChanged(change);
			}
		}
	}
	public void unrelateAcrossR2From(Linkleftside_c target) {
		unrelateAcrossR2From(target, true);
	}
	public void unrelateAcrossR2From(Linkleftside_c target,
			boolean notifyChanges) {
		if (target == null)
			return;

		if (Linkleftside == null)
			return; // already unrelated

		if (target != Linkleftside) {
			Exception e = new Exception();
			e.fillInStackTrace();
			CoreTestPlugin.logError(
					"Tried to unrelate from non-related instance across R2", e);
			return;
		}

		if (target != null) {
			target.clearBackPointerR2To(this);
		}

		if (Linkleftside != null) {

			m_llsid = Linkleftside.getLlsid();
			Linkleftside = null;
			target.removeRef();
			if (notifyChanges) {
				RelationshipChangeModelDelta change = new RelationshipChangeModelDelta(
						Modeleventnotification_c.DELTA_ELEMENT_UNRELATED, this,
						target, "2", "");
				Consistency.getDefaultInstance()
						.fireModelElementRelationChanged(change);
			}
		}
	}

	public static Linktest_c getOneCST_LTOnR2(Linkrightside_c[] targets) {
		return getOneCST_LTOnR2(targets, null);
	}

	public static Linktest_c getOneCST_LTOnR2(Linkrightside_c[] targets,
			ClassQueryInterface_c test) {
		Linktest_c ret_val = null;
		if (targets != null) {
			for (int i = 0; i < targets.length && ret_val == null; ++i) {
				ret_val = getOneCST_LTOnR2(targets[i], test);
			}
		}

		return ret_val;
	}

	public static Linktest_c getOneCST_LTOnR2(Linkrightside_c target) {
		return getOneCST_LTOnR2(target, null);
	}

	public static Linktest_c getOneCST_LTOnR2(Linkrightside_c target,
			boolean loadComponent) {
		return getOneCST_LTOnR2(target.getModelRoot(), target, null,
				loadComponent);
	}

	public static Linktest_c getOneCST_LTOnR2(Linkrightside_c target,
			ClassQueryInterface_c test) {
		if (target != null) {
			return getOneCST_LTOnR2(target.getModelRoot(), target, test);
		}
		return null;
	}

	public static Linktest_c getOneCST_LTOnR2(ModelRoot modelRoot,
			Linkrightside_c target, ClassQueryInterface_c test) {
		return getOneCST_LTOnR2(modelRoot, target, test, true);
	}

	public static Linktest_c getOneCST_LTOnR2(ModelRoot modelRoot,
			Linkrightside_c target, ClassQueryInterface_c test,
			boolean loadComponent) {
		return find_getOneCST_LTOnR2(modelRoot, target, test);
	}
	private static Linktest_c find_getOneCST_LTOnR2(ModelRoot modelRoot,
			Linkrightside_c target, ClassQueryInterface_c test) {
		if (target != null) {
			synchronized (target.backPointer_Linktest_R2) {
				for (int i = 0; i < target.backPointer_Linktest_R2.size(); ++i) {
					Linktest_c source = (Linktest_c) target.backPointer_Linktest_R2
							.get(i);
					if (source != null
							&& (test == null || test.evaluate(source))) {
						return source;
					}
				}
			}
		}
		// not found
		return null;
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkrightside_c[] targets) {
		return getManyCST_LTsOnR2(targets, null);
	}
	public static Linktest_c[] getManyCST_LTsOnR2(Linkrightside_c[] targets,
			boolean loadComponent) {
		return getManyCST_LTsOnR2(targets, null, loadComponent);
	}
	public static Linktest_c[] getManyCST_LTsOnR2(Linkrightside_c[] targets,
			ClassQueryInterface_c test) {
		return getManyCST_LTsOnR2(targets, test, true);
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkrightside_c[] targets,
			ClassQueryInterface_c test, boolean loadComponent) {

		if (targets == null || targets.length == 0 || targets[0] == null)
			return new Linktest_c[0];

		ModelRoot modelRoot = targets[0].getModelRoot();

		InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);

		Vector matches = new Vector();
		for (int i = 0; i < targets.length; i++) {
			synchronized (targets[i].backPointer_Linktest_R2) {
				for (int j = 0; j < targets[i].backPointer_Linktest_R2.size(); ++j) {
					Linktest_c source = (Linktest_c) targets[i].backPointer_Linktest_R2
							.get(j);
					if (source != null
							&& (test == null || test.evaluate(source))) {
						matches.add(source);
					}
				}
			}
		}
		if (matches.size() > 0) {
			Linktest_c[] ret_set = new Linktest_c[matches.size()];
			matches.copyInto(ret_set);
			return ret_set;
		} else {
			return new Linktest_c[0];
		}
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkrightside_c target) {
		if (target != null) {
			Linkrightside_c[] targetArray = new Linkrightside_c[1];
			targetArray[0] = target;
			return getManyCST_LTsOnR2(targetArray);
		} else {
			Linktest_c[] result = new Linktest_c[0];
			return result;
		}
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkrightside_c target,
			boolean loadComponent) {
		if (target != null) {
			Linkrightside_c[] targetArray = new Linkrightside_c[1];
			targetArray[0] = target;
			return getManyCST_LTsOnR2(targetArray, loadComponent);
		} else {
			Linktest_c[] result = new Linktest_c[0];
			return result;
		}
	}

	public static Linktest_c getOneCST_LTOnR2(Linkleftside_c[] targets) {
		return getOneCST_LTOnR2(targets, null);
	}

	public static Linktest_c getOneCST_LTOnR2(Linkleftside_c[] targets,
			ClassQueryInterface_c test) {
		Linktest_c ret_val = null;
		if (targets != null) {
			for (int i = 0; i < targets.length && ret_val == null; ++i) {
				ret_val = getOneCST_LTOnR2(targets[i], test);
			}
		}

		return ret_val;
	}

	public static Linktest_c getOneCST_LTOnR2(Linkleftside_c target) {
		return getOneCST_LTOnR2(target, null);
	}

	public static Linktest_c getOneCST_LTOnR2(Linkleftside_c target,
			boolean loadComponent) {
		return getOneCST_LTOnR2(target.getModelRoot(), target, null,
				loadComponent);
	}

	public static Linktest_c getOneCST_LTOnR2(Linkleftside_c target,
			ClassQueryInterface_c test) {
		if (target != null) {
			return getOneCST_LTOnR2(target.getModelRoot(), target, test);
		}
		return null;
	}

	public static Linktest_c getOneCST_LTOnR2(ModelRoot modelRoot,
			Linkleftside_c target, ClassQueryInterface_c test) {
		return getOneCST_LTOnR2(modelRoot, target, test, true);
	}

	public static Linktest_c getOneCST_LTOnR2(ModelRoot modelRoot,
			Linkleftside_c target, ClassQueryInterface_c test,
			boolean loadComponent) {
		return find_getOneCST_LTOnR2(modelRoot, target, test);
	}
	private static Linktest_c find_getOneCST_LTOnR2(ModelRoot modelRoot,
			Linkleftside_c target, ClassQueryInterface_c test) {
		if (target != null) {
			synchronized (target.backPointer_Linktest_R2) {
				for (int i = 0; i < target.backPointer_Linktest_R2.size(); ++i) {
					Linktest_c source = (Linktest_c) target.backPointer_Linktest_R2
							.get(i);
					if (source != null
							&& (test == null || test.evaluate(source))) {
						return source;
					}
				}
			}
		}
		// not found
		return null;
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkleftside_c[] targets) {
		return getManyCST_LTsOnR2(targets, null);
	}
	public static Linktest_c[] getManyCST_LTsOnR2(Linkleftside_c[] targets,
			boolean loadComponent) {
		return getManyCST_LTsOnR2(targets, null, loadComponent);
	}
	public static Linktest_c[] getManyCST_LTsOnR2(Linkleftside_c[] targets,
			ClassQueryInterface_c test) {
		return getManyCST_LTsOnR2(targets, test, true);
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkleftside_c[] targets,
			ClassQueryInterface_c test, boolean loadComponent) {

		if (targets == null || targets.length == 0 || targets[0] == null)
			return new Linktest_c[0];

		ModelRoot modelRoot = targets[0].getModelRoot();

		InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);

		Vector matches = new Vector();
		for (int i = 0; i < targets.length; i++) {
			synchronized (targets[i].backPointer_Linktest_R2) {
				for (int j = 0; j < targets[i].backPointer_Linktest_R2.size(); ++j) {
					Linktest_c source = (Linktest_c) targets[i].backPointer_Linktest_R2
							.get(j);
					if (source != null
							&& (test == null || test.evaluate(source))) {
						matches.add(source);
					}
				}
			}
		}
		if (matches.size() > 0) {
			Linktest_c[] ret_set = new Linktest_c[matches.size()];
			matches.copyInto(ret_set);
			return ret_set;
		} else {
			return new Linktest_c[0];
		}
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkleftside_c target) {
		if (target != null) {
			Linkleftside_c[] targetArray = new Linkleftside_c[1];
			targetArray[0] = target;
			return getManyCST_LTsOnR2(targetArray);
		} else {
			Linktest_c[] result = new Linktest_c[0];
			return result;
		}
	}

	public static Linktest_c[] getManyCST_LTsOnR2(Linkleftside_c target,
			boolean loadComponent) {
		if (target != null) {
			Linkleftside_c[] targetArray = new Linkleftside_c[1];
			targetArray[0] = target;
			return getManyCST_LTsOnR2(targetArray, loadComponent);
		} else {
			Linktest_c[] result = new Linktest_c[0];
			return result;
		}
	}

	public void batchRelate(ModelRoot modelRoot, boolean notifyChanges,
			boolean searchAllRoots) {
		batchRelate(modelRoot, false, notifyChanges, searchAllRoots);
	}

	public void batchRelate(ModelRoot modelRoot, boolean relateProxies,
			boolean notifyChanges, boolean searchAllRoots) {
		InstanceList instances = null;
		ModelRoot baseRoot = modelRoot;

		// R2
		Linkleftside_c relInst63 = (Linkleftside_c) baseRoot.getInstanceList(
				Linkleftside_c.class).get(
				new Object[]{new UUID(0, new Long(m_llsid))});
		// if there was no local element, check for any global elements
		// failing that proceed to check other model roots
		if (relInst63 == null) {
			relInst63 = (Linkleftside_c) Ooaofooa.getDefaultInstance()
					.getInstanceList(Linkleftside_c.class)
					.get(new Object[]{new UUID(0, new Long(m_llsid))});
		}
		if (relInst63 == null && searchAllRoots && !baseRoot.isCompareRoot()) {
			Consistency[] roots = Consistency.getInstances();
			for (int i = 0; i < roots.length; i++) {
				if (roots[i].isCompareRoot()) {
					// never use elements from any compare root
					continue;
				}
				relInst63 = (Linkleftside_c) roots[i].getInstanceList(
						Linkleftside_c.class).get(
						new Object[]{new UUID(0, new Long(m_llsid))});
				if (relInst63 != null)
					break;
			}
		}
		//synchronized
		if (relInst63 != null) {
			if (relateProxies || !isProxy()
					|| (inSameComponent(this, relInst63) && !isProxy())) {
				relInst63.relateAcrossR2To(this, notifyChanges);
			}
		}

		Linkrightside_c relInst64 = (Linkrightside_c) baseRoot.getInstanceList(
				Linkrightside_c.class).get(
				new Object[]{new UUID(0, new Long(m_lrsid))});
		// if there was no local element, check for any global elements
		// failing that proceed to check other model roots
		if (relInst64 == null) {
			relInst64 = (Linkrightside_c) Ooaofooa.getDefaultInstance()
					.getInstanceList(Linkrightside_c.class)
					.get(new Object[]{new UUID(0, new Long(m_lrsid))});
		}
		if (relInst64 == null && searchAllRoots && !baseRoot.isCompareRoot()) {
			Consistency[] roots = Consistency.getInstances();
			for (int i = 0; i < roots.length; i++) {
				if (roots[i].isCompareRoot()) {
					// never use elements from any compare root
					continue;
				}
				relInst64 = (Linkrightside_c) roots[i].getInstanceList(
						Linkrightside_c.class).get(
						new Object[]{new UUID(0, new Long(m_lrsid))});
				if (relInst64 != null)
					break;
			}
		}
		//synchronized
		if (relInst64 != null) {
			if (relateProxies || !isProxy()
					|| (inSameComponent(this, relInst64) && !isProxy())) {
				relInst64.relateAcrossR2To(this, notifyChanges);
			}
		}

	}
	public void batchUnrelate(boolean notifyChanges) {
		NonRootModelElement inst = null;
		// R2
		// CST_LLS
		inst = Linkleftside;
		unrelateAcrossR2From(Linkleftside, notifyChanges);
		if (inst != null) {
			inst.removeRef();
		}
		// CST_LRS
		inst = Linkrightside;
		unrelateAcrossR2From(Linkrightside, notifyChanges);
		if (inst != null) {
			inst.removeRef();
		}
	}
	public static void batchRelateAll(ModelRoot modelRoot,
			boolean notifyChanges, boolean searchAllRoots) {
		batchRelateAll(modelRoot, notifyChanges, searchAllRoots, false);
	}
	public static void batchRelateAll(ModelRoot modelRoot, boolean notifyChanges, boolean searchAllRoots, boolean relateProxies)
  {
	InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);
    synchronized(instances) {
        Iterator<NonRootModelElement> cursor = instances.iterator() ;
    	while (cursor.hasNext())
	    {
            final Linktest_c inst = (Linktest_c)cursor.next() ;
	        inst.batchRelate(modelRoot, relateProxies, notifyChanges, searchAllRoots );
	    }
	}
  }
	public static void clearInstances(ModelRoot modelRoot) {
		InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);
		synchronized (instances) {
			for (int i = instances.size() - 1; i >= 0; i--) {
				((NonRootModelElement) instances.get(i)).delete_unchecked();
			}

		}
	}

	public static Linktest_c LinktestInstance(ModelRoot modelRoot,
			ClassQueryInterface_c test, boolean loadComponent) {
		Linktest_c result = findLinktestInstance(modelRoot, test, loadComponent);
		return result;
	}
	private static Linktest_c findLinktestInstance(ModelRoot modelRoot,
			ClassQueryInterface_c test, boolean loadComponent) {
		InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);
		synchronized (instances) {
			for (int i = 0; i < instances.size(); ++i) {
				Linktest_c x = (Linktest_c) instances.get(i);
				if (test == null || test.evaluate(x)) {
					return x;
				}
			}
		}
		return null;
	}
	public static Linktest_c LinktestInstance(ModelRoot modelRoot,
			ClassQueryInterface_c test) {
		return LinktestInstance(modelRoot, test, true);
	}

	public static Linktest_c LinktestInstance(ModelRoot modelRoot) {
		return LinktestInstance(modelRoot, null, true);
	}

	public static Linktest_c[] LinktestInstances(ModelRoot modelRoot,
			ClassQueryInterface_c test, boolean loadComponent) {
		InstanceList instances = modelRoot.getInstanceList(Linktest_c.class);
		Vector matches = new Vector();
		synchronized (instances) {
			for (int i = 0; i < instances.size(); ++i) {
				Linktest_c x = (Linktest_c) instances.get(i);
				if (test == null || test.evaluate(x)) {
					matches.add(x);
				}
			}
			if (matches.size() > 0) {
				Linktest_c[] ret_set = new Linktest_c[matches.size()];
				matches.copyInto(ret_set);
				return ret_set;
			} else {
				return new Linktest_c[0];
			}
		}
	}
	public static Linktest_c[] LinktestInstances(ModelRoot modelRoot,
			ClassQueryInterface_c test) {
		return LinktestInstances(modelRoot, test, true);
	}
	public static Linktest_c[] LinktestInstances(ModelRoot modelRoot) {
		return LinktestInstances(modelRoot, null, true);
	}

	public boolean delete() {
		boolean result = super.delete();
		boolean delete_error = false;
		String errorMsg = "The following relationships were not torn down by the linkTest.dispose call: ";
		Linkleftside_c testR2Inst = Linkleftside_c.getOneCST_LLSOnR2(this,
				false);

		if (testR2Inst != null) {
			delete_error = true;
			errorMsg = errorMsg + "2 ";
		}

		Linkrightside_c testR2InstOth = Linkrightside_c.getOneCST_LRSOnR2(this,
				false);

		if (testR2InstOth != null) {
			delete_error = true;
			errorMsg = errorMsg + "2 ";
		}
		if (delete_error == true) {

			if (CoreTestPlugin.getDefault().isDebugging()) {
				Consistency.log.println(ILogger.DELETE, "linkTest", errorMsg);
			} else {
				Exception e = new Exception();
				e.fillInStackTrace();
				CoreTestPlugin.logError(errorMsg, e);
			}
		}
		return result;
	}

	// end declare instance pool

	// declare attribute accessors
	public boolean isUUID(String attributeName) {
		return false;
	}
	// declare attribute accessors
	public int getLlsid() {
		if (Linkleftside != null) {
			return Linkleftside.getLlsid();
		}
		return 0;
	}

	public int getLlsidCachedValue() {
		return m_llsid;
	}

	public void setLlsid(int newValue) {
		if (m_llsid == newValue) {
			return;
		}
		AttributeChangeModelDelta change = new AttributeChangeModelDelta(
				Modeleventnotification_c.DELTA_ATTRIBUTE_CHANGE, this, "Llsid",
				new Integer(m_llsid), new Integer(newValue), true);

		m_llsid = newValue;
		Consistency.getDefaultInstance().fireModelElementAttributeChanged(
				change);
	}
	public int getLrsid() {
		if (Linkrightside != null) {
			return Linkrightside.getLrsid();
		}
		return 0;
	}

	public int getLrsidCachedValue() {
		return m_lrsid;
	}

	public void setLrsid(int newValue) {
		if (m_lrsid == newValue) {
			return;
		}
		AttributeChangeModelDelta change = new AttributeChangeModelDelta(
				Modeleventnotification_c.DELTA_ATTRIBUTE_CHANGE, this, "Lrsid",
				new Integer(m_lrsid), new Integer(newValue), true);

		m_lrsid = newValue;
		Consistency.getDefaultInstance().fireModelElementAttributeChanged(
				change);
	}
	// end declare accessors
	public static void checkClassConsistency(ModelRoot modelRoot) {
		Ooaofooa.log.println(ILogger.OPERATION, "linkTest", //$NON-NLS-1$
				" Operation entered: linkTest::checkClassConsistency"); //$NON-NLS-1$
		if (Boolean.valueOf(System.getenv("PTC_MCC_ENABLED")) == false) { //$NON-NLS-1$
			return;
		}
		Linktest_c[] objs = Linktest_c
				.LinktestInstances(modelRoot, null, false);

		for (int i = 0; i < objs.length; i++) {
			objs[i].checkConsistency();
		}
	}
	public boolean checkConsistency() {
		Ooaofooa.log.println(ILogger.OPERATION, "linkTest", //$NON-NLS-1$
				" Operation entered: linkTest::checkConsistency"); //$NON-NLS-1$
		if (Boolean.valueOf(System.getenv("PTC_MCC_ENABLED")) == false) { //$NON-NLS-1$
			return true;
		}
		ModelRoot modelRoot = getModelRoot();
		boolean retval = true;
		class Linktest_c_test66_c implements ClassQueryInterface_c {
			Linktest_c_test66_c(int p67, int p68) {
				m_p67 = p67;
				m_p68 = p68;
			}
			private int m_p67;
			private int m_p68;
			public boolean evaluate(Object candidate) {
				Linktest_c selected = (Linktest_c) candidate;
				boolean retval = false;
				retval = (selected.getLlsid() == (m_p67))
						& (selected.getLrsid() == (m_p68));
				return retval;
			}
		}

		Linktest_c[] objs65 = Linktest_c.LinktestInstances(modelRoot,
				new Linktest_c_test66_c(getLlsid(), getLrsid()));

		if (((objs65.length) == 0)) {

			if (CoreTestPlugin.getDefault().isDebugging()) {
				Consistency.log
						.println(ILogger.CONSISTENCY,
								"linkTest", //$NON-NLS-1$
								"Consistency: Object: linkTest: Cardinality of an identifier is zero. " //$NON-NLS-1$
										+ "Actual Value: " + Integer.toString(objs65.length)); //$NON-NLS-1$
			} else {
				Exception e = new Exception();
				CoreTestPlugin.logError(
						"Consistency: Object: linkTest: Cardinality of an identifier is zero. " //$NON-NLS-1$ 
								+ "Actual Value: " //$NON-NLS-1$
								+ Integer.toString(objs65.length), e);
			}
			retval = false;

		}

		if (((objs65.length) > 1)) {

			if (CoreTestPlugin.getDefault().isDebugging()) {
				Consistency.log
						.println(ILogger.CONSISTENCY,
								"linkTest", //$NON-NLS-1$
								"Consistency: Object: linkTest: Cardinality of an identifier is greater than 1. " //$NON-NLS-1$
										+ "Actual Value: " //$NON-NLS-1$ 
										+ Integer.toString(objs65.length)
										+ " llsID: " + Integer.toString(getLlsid()) + " lrsID: " + Integer.toString(getLrsid())); //$NON-NLS-1$
			} else {
				Exception e = new Exception();
				CoreTestPlugin
						.logError(
								"Consistency: Object: linkTest: Cardinality of an identifier is greater than 1. " //$NON-NLS-1$ 
										+ "Actual Value: " //$NON-NLS-1$
										+ Integer.toString(objs65.length)
										+ " llsID: " + Integer.toString(getLlsid()) + " lrsID: " + Integer.toString(getLrsid()), e); //$NON-NLS-1$
			}
			retval = false;

		}

		// linkTest is a link class in association: rel.Numb = 2
		// The one side class in the association is: linkLeftSide
		class Linkleftside_c_test72_c implements ClassQueryInterface_c {
			Linkleftside_c_test72_c(int p73) {
				m_p73 = p73;
			}
			private int m_p73;
			public boolean evaluate(Object candidate) {
				Linkleftside_c selected = (Linkleftside_c) candidate;
				boolean retval = false;
				retval = (selected.getLlsid() == (m_p73));
				return retval;
			}
		}

		Linkleftside_c[] objs71 = Linkleftside_c.LinkleftsideInstances(
				modelRoot, new Linkleftside_c_test72_c(getLlsid()));

		// The one side class is unconditional
		// The multiplicity of the one side class is one
		if (((objs71.length) != 1)) {

			if (CoreTestPlugin.getDefault().isDebugging()) {
				Consistency.log
						.println(ILogger.CONSISTENCY,
								"linkTest", //$NON-NLS-1$
								"Consistency: Object: linkTest: Association: 2: Cardinality of one side of link is not equal to 1. " //$NON-NLS-1$
										+ "Actual Value: " + Integer.toString(objs71.length)); //$NON-NLS-1$
			} else {
				Exception e = new Exception();
				CoreTestPlugin
						.logError(
								"Consistency: Object: linkTest: Association: 2: Cardinality of one side of link is not equal to 1. " //$NON-NLS-1$ 
										+ "Actual Value: " //$NON-NLS-1$
										+ Integer.toString(objs71.length), e);
			}
			retval = false;

		}

		// Other side
		// The other side class in the association is: linkRightSide
		class Linkrightside_c_test75_c implements ClassQueryInterface_c {
			Linkrightside_c_test75_c(int p76) {
				m_p76 = p76;
			}
			private int m_p76;
			public boolean evaluate(Object candidate) {
				Linkrightside_c selected = (Linkrightside_c) candidate;
				boolean retval = false;
				retval = (selected.getLrsid() == (m_p76));
				return retval;
			}
		}

		Linkrightside_c[] objs74 = Linkrightside_c.LinkrightsideInstances(
				modelRoot, new Linkrightside_c_test75_c(getLrsid()));

		// The other side class is unconditional
		// The multiplicity of the other side class is one
		if (((objs74.length) != 1)) {

			if (CoreTestPlugin.getDefault().isDebugging()) {
				Consistency.log
						.println(ILogger.CONSISTENCY,
								"linkTest", //$NON-NLS-1$
								"Consistency: Object: linkTest: Association: 2: Cardinality of other side of link is not equal to 1. " //$NON-NLS-1$
										+ "Actual Value: " + Integer.toString(objs74.length)); //$NON-NLS-1$
			} else {
				Exception e = new Exception();
				CoreTestPlugin
						.logError(
								"Consistency: Object: linkTest: Association: 2: Cardinality of other side of link is not equal to 1. " //$NON-NLS-1$ 
										+ "Actual Value: " //$NON-NLS-1$
										+ Integer.toString(objs74.length), e);
			}
			retval = false;

		}

		return retval;
	}

	public Object getAdapter(Class adapter) {
		Object superAdapter = super.getAdapter(adapter);
		if (superAdapter != null) {
			return superAdapter;
		}
		return null;
	}
} // end linkTest
