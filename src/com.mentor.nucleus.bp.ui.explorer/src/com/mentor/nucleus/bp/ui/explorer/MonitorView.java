package com.mentor.nucleus.bp.ui.explorer;
//======================================================================
//
// File: com/mentor/nucleus/bp/ui/explorer/MonitorView.java
//
// WARNING:      Do not edit this generated file
// Generated by: arc/create_mon_explorer_view.inc
// Version:      $Revision$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
//
//======================================================================
//
// This class is the main entry point for the Monitor View.
// It is responsible for building the presentation to the user and
// for providing the interface to the Eclipse infrastructure.
//
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.GroupMarker;
import org.eclipse.jface.action.IMenuListener;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.viewers.DecoratingLabelProvider;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.IOpenListener;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.OpenEvent;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerFilter;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.IWorkbenchActionConstants;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.actions.ExportResourcesAction;
import org.eclipse.ui.actions.ImportResourcesAction;
import org.eclipse.ui.actions.NewWizardMenu;
import org.eclipse.ui.actions.RefreshAction;
import org.eclipse.ui.help.WorkbenchHelp;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.ui.views.framelist.BackAction;
import org.eclipse.ui.views.framelist.ForwardAction;
import org.eclipse.ui.views.framelist.FrameList;
import org.eclipse.ui.views.framelist.TreeViewerFrameSource;
import org.eclipse.ui.views.framelist.UpAction;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.eclipse.ui.views.properties.PropertySheetPage;
import org.osgi.framework.Bundle;

import com.mentor.nucleus.bp.core.*;
import com.mentor.nucleus.bp.core.common.*;
import com.mentor.nucleus.bp.core.ui.DeleteAction;
import com.mentor.nucleus.bp.core.ui.RenameAction;
import com.mentor.nucleus.bp.core.ui.Selection;
import com.mentor.nucleus.bp.core.util.UIUtil;

import com.mentor.nucleus.bp.ui.properties.ModelPropertySourceProvider;

/**
 * ExplorerView allows the user to navigate the BridgePoint
 * metamodel. It provides a tree view analogous to that provided
 * by the Java Package Explorer.
 * 
 * @see ViewPart
 */
public class MonitorView extends ViewPart {
	private static final String COLLAPSE = "Collapse All";
	private static final String OPEN = "open";
	private FrameList frames;
	protected ExplorerTreeViewer treeViewer;
	protected MonitorLabelProvider labelProvider;
	protected MenuManager menuManager;
	protected Action collapseAll, linkWithEditor;
	protected Action back, fwd, up;
	protected Action cut, copy, paste;
	protected Action open, delete, rename;
	protected Action fileImport, fileExport;
	protected Action treeRefresh;
	protected ViewerFilter filterStatics;

	private IModelChangeListener m_modelChangeListener;
	private ITransactionListener m_transactionListener;
	private ISelectionChangedListener m_selChangedListener;
	private static MonitorView instance = null;

	private static Selection selection = Selection.getInstance();

	/**
	 * The constructor.
	 */
	public MonitorView() {
		instance = this;
	}
	/**
	 * Returns the tree viewer for the Explorer window
	 */
	public ExplorerTreeViewer getTreeViewer() {
		return treeViewer;
	}

	public static MonitorView instance() {
		if (instance == null) {
			new MonitorView();
		}
		return instance;
	}
	/*
	 * @see IWorkbenchPart#createPartControl(Composite)
	 */
	public void createPartControl(Composite parent) {
		// Create the view's layout
		FillLayout layout = new FillLayout();
		parent.setLayout(layout);
		treeViewer = new ExplorerTreeViewer(parent);
		treeViewer.setContentProvider(new MonitorContentProvider());
		labelProvider = new MonitorLabelProvider();
		treeViewer.setLabelProvider(labelProvider);
		treeViewer.setUseHashlookup(true);
		// Create menu, toolbar and filters.
		createActions();
		createMenus();
		createToolbar();
		hookListeners();
		initLabelProvider(treeViewer);
		treeViewer.setInput(Ooaofooa.getDefaultInstance());
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.DELETE.getId(), delete);
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.RENAME.getId(), rename);
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.COPY.getId(), copy);
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.CUT.getId(), cut);
		getViewSite().getActionBars().setGlobalActionHandler(
				ActionFactory.PASTE.getId(), paste);
	}
	/**
	 * Hook up all the listeners needed by the Monitor View
	 */
	protected void hookListeners() {
    treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        // Transfer the selection to the model
        selection.setSelection(event.getSelection());
      }
    });
    m_selChangedListener = new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
	  	keyActionsActivation();
        if (!getTreeViewer().getTree().isDisposed()) {
          if (linkWithEditor.isChecked()){
            // transfer the selection to the tree, but avoid having the tree 
            // viewer report its selection change to its listeners, as if what the 
            // model is reporting as selected is not contained in the tree
            // (such as when a connector is selected), we don't want the
            // tree's newly empty selection being propagated back to the model 
            // by the treeview-listener, above; see issue 453 for more context
            IStructuredSelection selection = (IStructuredSelection)event.getSelection();
            ExplorerTreeViewer viewer = getTreeViewer();
            viewer.setSelectionToWidget(selection, true);
            
            // scroll to reveal all elements of the new selection
            for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
              Object element = iterator.next();
              viewer.reveal(element);
            }
          }
        }
      }
    };
    selection.addSelectionChangedListener(m_selChangedListener);
    m_modelChangeListener = new ModelChangeAdapter() {
		public void modelElementLoaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				ExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((MonitorContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
		public void modelElementUnloaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				ExplorerTreeViewer viewer = getTreeViewer();
				Object parent = ((MonitorContentProvider) viewer.getContentProvider()).getParent(modelElement);
				UIUtil.refreshViewer(viewer, parent);
			}
		}
	};
    Ooaofooa.addModelChangeListenerToAll(m_modelChangeListener);
	m_transactionListener = new ITransactionListener() {
			@Override
			public void transactionCancelled(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}

			@Override
			public void transactionEnded(Transaction transaction) {
				PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
					
					@Override
					public void run() {
						getTreeViewer().refresh();	
					}
				});
			}

			@Override
			public void transactionStarted(Transaction transaction) {
				// TODO Auto-generated method stub
				
			}
		};
	TransactionManager.getSingleton().addTransactionListener(m_transactionListener);
    treeViewer.addOpenListener(new IOpenListener() {
      public void open(OpenEvent event) {
        handleOpen();
      }
    });
  }
	public static final boolean classInTree(Object o) {
		if (o instanceof ReferentialAttribute_c)
			return true;
		if (o instanceof AttributeReferenceInClass_c)
			return true;
		return false;
	}
	/**
	 * Create the Actions provided by the Monitor View
	 */
	protected void createActions() {
		frames = new FrameList(new TreeViewerFrameSource(getTreeViewer()));
		back = new BackAction(frames) {
			public void run() {
			}
		};
		fwd = new ForwardAction(frames) {
			public void run() {
			}
		};
		up = new UpAction(frames) {
			public void run() {
			}
		};
		collapseAll = new Action(COLLAPSE) {
			public void run() {
				getTreeViewer().collapseAll();
			}
		};
		collapseAll.setToolTipText(COLLAPSE);
		collapseAll.setImageDescriptor(CorePlugin
				.getImageDescriptor("collapseall.gif")); //$NON-NLS-1$
		WorkbenchHelp.setHelp(collapseAll,
				IModelExplorerHelpContextIds.COLLAPSE_ALL_ACTION);
		linkWithEditor = new Action(IWorkbenchActionConstants.SYNC_EDITOR) {
			public void run() {
				IStructuredSelection selection = (IStructuredSelection) Selection
						.getInstance().getSelection();
				getTreeViewer().setSelection(selection);
				for (Iterator iterator = selection.iterator(); iterator
						.hasNext();) {
					Object element = iterator.next();
					getTreeViewer().reveal(element);
				}
			}
		};
		linkWithEditor.setChecked(false);
		linkWithEditor.setText("Link With Editor");
		linkWithEditor.setToolTipText("Link with Editor");
		linkWithEditor.setImageDescriptor(CorePlugin
				.getImageDescriptor("synced.gif")); //$NON-NLS-1$
		// 'New' is provided as a sub-menu only. See 'createMenus'
		open = new Action(OPEN) {
			public void run() {
				handleOpen();
			}
		};
		open.setText("Open");
		open.setToolTipText("Open this model Element");
		// 'Open With' is provided as a sub-menu only. See 'createMenus'
		cut = new Action(ActionFactory.CUT.getId()) {
			public void run() {
			}
		};
		cut.setText("Cut");
		cut.setToolTipText("Cut this model Element to the clipboard");
		cut.setImageDescriptor(CorePlugin.getImageDescriptor("cut_edit.gif")); //$NON-NLS-1$
		cut.setEnabled(false); // Retargetable Actions work removes this line
		copy = new Action(ActionFactory.COPY.getId()) {
			public void run() {
			}
		};
		copy.setText("Copy");
		copy.setToolTipText("Copy this model Element to the clipboard");
		copy.setImageDescriptor(CorePlugin.getImageDescriptor("copy_edit.gif")); //$NON-NLS-1$
		copy.setEnabled(false); // Retargetable Actions work removes this line
		paste = new Action(ActionFactory.PASTE.getId()) {
			public void run() {
			}
		};
		paste.setText("Paste");
		paste.setToolTipText("Paste from the clipboard");
		paste.setImageDescriptor(CorePlugin
				.getImageDescriptor("paste_edit.gif")); //$NON-NLS-1$
		paste.setEnabled(false); // Retargetable Actions work removes this line
		//
		// Delete and Rename are retargetable actions defined by core.
		//
		delete = CorePlugin.getDeleteAction();
		rename = CorePlugin.getRenameAction(treeViewer);
		//
		fileImport = new Action(ActionFactory.IMPORT.getId()) {
			public void run() {
				ImportResourcesAction ira = new ImportResourcesAction(
						CorePlugin.getDefault().getWorkbench()
								.getActiveWorkbenchWindow());
				ira.run();
			}
		};
		fileImport.setText("Import...");
		fileImport.setToolTipText("Import a BridgePoint file");
		fileImport.setImageDescriptor(CorePlugin
				.getImageDescriptor("import_wiz.gif")); //$NON-NLS-1$
		fileExport = new Action(ActionFactory.EXPORT.getId()) {
			public void run() {
				ExportResourcesAction era = new ExportResourcesAction(
						CorePlugin.getDefault().getWorkbench()
								.getActiveWorkbenchWindow());
				era.run();
			}
		};
		fileExport.setText("Export...");
		fileExport.setToolTipText("Export a BridgePoint file");
		fileExport.setImageDescriptor(CorePlugin
				.getImageDescriptor("export_wiz.gif")); //$NON-NLS-1$
		treeRefresh = new Action(ActionFactory.REFRESH.getId()) {
			public void run() {
				RefreshAction ra = new RefreshAction(CorePlugin.getDefault()
						.getWorkbench().getActiveWorkbenchWindow().getShell());
				ra.run();
				getTreeViewer().refresh();
			}
		};
		treeRefresh.setText("Refresh");
		treeRefresh.setToolTipText("Refresh the tree");
		treeRefresh.setImageDescriptor(CorePlugin
				.getImageDescriptor("refresh.gif")); //$NON-NLS-1$
		treeRefresh.setAccelerator(SWT.F5);
		treeRefresh.setActionDefinitionId("org.eclipse.ui.file.refresh"); //$NON-NLS-1$
		getSite().getKeyBindingService().registerAction(treeRefresh);

	}
	/**
	 * Create the menus for the monitor View
	 */
	protected void createMenus() {
		// Context Menu
		MenuManager menuManager = new MenuManager("#PopupMenu"); //$NON-NLS-1$
		menuManager.setRemoveAllWhenShown(true);
		final MenuManager createMenuManager = new MenuManager(
				"Ne&w", "com.mentor.nucleus.bp.ui.newroot"); //$NON-NLS-2$
		final MenuManager openMenuManager = new MenuManager(
				"Open Wit&h", "com.mentor.nucleus.bp.ui.openroot"); //$NON-NLS-2$

		final MenuManager classesMenu = new MenuManager(
				"Classes", "com.mentor.nucleus.bp.ui.classroot"); //$NON-NLS-2$
		final MenuManager componentsMenu = new MenuManager(
				"Components", "com.mentor.nucleus.bp.ui.componentroot"); //$NON-NLS-2$
		final MenuManager externalMenu = new MenuManager(
				"External", "com.mentor.nucleus.bp.ui.externalroot"); //$NON-NLS-2$
		final MenuManager interactionMenu = new MenuManager(
				"Interaction", "com.mentor.nucleus.bp.ui.interactionroot"); //$NON-NLS-2$
		final MenuManager activityMenu = new MenuManager(
				"Activity", "com.mentor.nucleus.bp.ui.activityroot"); //$NON-NLS-2$
		final MenuManager typesMenu = new MenuManager(
				"Types", "com.mentor.nucleus.bp.ui.typeroot"); //$NON-NLS-2$
		final MenuManager useCaseMenu = new MenuManager(
				"Usecase", "com.mentor.nucleus.bp.ui.usecaseroot"); //$NON-NLS-2$

		menuManager.addMenuListener(new IMenuListener() {
			public void menuAboutToShow(IMenuManager mgr) {
				mgr.add(createMenuManager);
				createMenuManager.removeAll();
				createMenuManager.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newmenu")); //$NON-NLS-1$

				createMenuManager.add(activityMenu);
				activityMenu.removeAll();
				activityMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newactivitymenu"));

				createMenuManager.add(classesMenu);
				classesMenu.removeAll();
				classesMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newclassmenu"));

				createMenuManager.add(componentsMenu);
				componentsMenu.removeAll();
				componentsMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newcomponentmenu"));

				createMenuManager.add(externalMenu);
				externalMenu.removeAll();
				externalMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newexternalmenu"));

				createMenuManager.add(interactionMenu);
				interactionMenu.removeAll();
				interactionMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newinteractionmenu"));

				createMenuManager.add(typesMenu);
				typesMenu.removeAll();
				typesMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newtypemenu"));

				createMenuManager.add(useCaseMenu);
				useCaseMenu.removeAll();
				useCaseMenu.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.newusecasemenu"));

				new NewWizardMenu(createMenuManager, getSite()
						.getWorkbenchWindow(), false);
				mgr.add(open);
				mgr.add(openMenuManager);
				openMenuManager.removeAll();
				openMenuManager.add(new GroupMarker(
						"com.mentor.nucleus.bp.ui.openmenu")); //$NON-NLS-1$
				mgr.add(new Separator(
						"com.mentor.nucleus.bp.ui.context-internal")); //$NON-NLS-1$
				mgr.add(new Separator(
						"com.mentor.nucleus.bp.ui.context-internal-end")); //$NON-NLS-1$
				mgr.add(cut);
				mgr.add(copy);
				mgr.add(paste);
				mgr.add(delete);
				mgr.add(rename);
				mgr.add(new Separator());
				mgr.add(fileImport);
				mgr.add(fileExport);
				mgr.add(new Separator());
				mgr.add(treeRefresh);
				// If this is omitted, the platform complains because
				// it can't allow third party plug-ins to extend the menu
				// This is important for those who wish to use change
				// management plugins because Team menu items are added here.
				mgr.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
			}
		});
		Menu menu = menuManager.createContextMenu(treeViewer.getTree());
		treeViewer.getTree().setMenu(menu);
		getSite().setSelectionProvider(selection);
		getSite().registerContextMenu(menuManager, selection);
		// Titlebar Menu
		IMenuManager rootMenuManager = getViewSite().getActionBars()
				.getMenuManager();
		rootMenuManager.setRemoveAllWhenShown(true);
		rootMenuManager.addMenuListener(new IMenuListener() {
			public void menuAboutToShow(IMenuManager mgr) {
				fillMenu(mgr);
			}
		});
		fillMenu(rootMenuManager);
	}
	/**
	 * Fill the Explorer's Titlebar dropdown menu 
	 */
	protected void fillMenu(IMenuManager rootMenuManager) {
		rootMenuManager.add(new Separator(
				IWorkbenchActionConstants.MB_ADDITIONS));
		rootMenuManager.add(linkWithEditor);
	}
	/**
	 * Create the tool bar for the Monitor View 
	 */
	protected void createToolbar() {
		IActionBars actionBars = getViewSite().getActionBars();
		actionBars.setGlobalActionHandler(ActionFactory.BACK.getId(), back);
		actionBars.setGlobalActionHandler(ActionFactory.FORWARD.getId(), fwd);
		actionBars.setGlobalActionHandler(ActionFactory.UP.getId(), up);
		IToolBarManager toolBarManager = actionBars.getToolBarManager();
		toolBarManager.add(back);
		toolBarManager.add(fwd);
		toolBarManager.add(up);
		toolBarManager.add(new Separator());
		toolBarManager.add(collapseAll);
		toolBarManager.add(linkWithEditor);
	}
	/*
	 * @see IWorkbenchPart#setFocus()
	 */
	public void setFocus() {
	}
	/**
	 * Returns an adapter if available
	 * @see IAdaptable#getAdapter
	 */
	public Object getAdapter(Class adapter) {
		if (adapter.equals(IPropertySheetPage.class)) {
			return getPropertySheet();
		}
		return super.getAdapter(adapter);
	}
	/**
	 * return a property sheet if available
	 */
	protected IPropertySheetPage getPropertySheet() {
		PropertySheetPage pss = new PropertySheetPage();
		pss.setPropertySourceProvider(new ModelPropertySourceProvider());
		return pss;
	}
	/**
	 * Fire up an editor
	 */
	private IEditorPart handleOpen() {

		IStructuredSelection sel = (IStructuredSelection) selection
				.getSelection();
		if (sel.isEmpty()) {
			return null;
		}
		Object current = sel.iterator().next();
		String name = current.getClass().getName();
		//
		// Get the registry
		//
		IExtensionRegistry reg = Platform.getExtensionRegistry();
		//
		// Get all the plugins that have extended this point
		//
		IExtensionPoint extPt = reg
				.getExtensionPoint("com.mentor.nucleus.bp.core.editors"); //$NON-NLS-1$
		IExtension[] exts = extPt.getExtensions();
		// Repeat for each extension until we find a default editor
		for (int i = 0; i < exts.length; i++) {
			IConfigurationElement[] elems = exts[i].getConfigurationElements();
			for (int j = 0; j < elems.length; j++) {
				// Find the editor elements
				if (elems[j].getName().equals("editor")) { //$NON-NLS-1$
					IConfigurationElement[] edElems = elems[j].getChildren();
					for (int k = 0; k < edElems.length; k++) {
						//
						// Is this editor the default for the current model element ?
						//
						if (edElems[k].getName().equals("defaultFor") && //$NON-NLS-1$
								edElems[k].getAttribute("class").equals(name)) { //$NON-NLS-1$
							try {
								//
								// Get the class supplied for the input
								//
								Bundle bundle = Platform
										.getBundle(elems[j]
												.getDeclaringExtension()
												.getNamespace());
								Class inputClass = bundle.loadClass(elems[j]
										.getAttribute("input"));//$NON-NLS-1$
								Class[] type = new Class[1];
								type[0] = Object.class;
								//
								// Dynamically get the method createInstance, the supplied class must implement this
								//
								Method createInstanceMethod = inputClass
										.getMethod("createInstance", type); //$NON-NLS-1$
								Object[] args = new Object[1];
								args[0] = current;
								//
								// Invoke the method.
								// The method is static; no instance is needed, so first argument is null
								//
								IEditorInput input = (IEditorInput) createInstanceMethod
										.invoke(null, args);
								//
								// pass the input to the Eclipse editor, along with the class name supplied by
								// the extending plugin.
								//
								if (input != null) {
									return PlatformUI
											.getWorkbench()
											.getActiveWorkbenchWindow()
											.getActivePage()
											.openEditor(
													input,
													elems[j].getAttribute("class")); //$NON-NLS-1$
								}
								return null;
							} catch (ClassNotFoundException e) {
								ExplorerPlugin.logError(
										"Input Class not found", e);//$NON-NLS-1$
							} catch (NoSuchMethodException e) {
								ExplorerPlugin
										.logError(
												"Class does not implement static method createInstance", e);//$NON-NLS-1$
							} catch (InvocationTargetException e) {
								// In the situation where an attempt is made to open an activity editor on an Attribute,
								// we ignore the error.  The reason is that this model element has 2 different editors
								// associated with.  When it is a MDA we open the activity editor, when it is not an
								// MDA we still try to open the activity editor, but there is not one and this exception
								// gets thrown.  We ignore the exception in this situation, and the description editor is
								// then opened as it should be.
								boolean ignoreError = (elems[j].getAttribute(
										"input")
										.contains("ActivityEditorInput") && name
										.contains("Attribute_c"));
								if (!ignoreError) {
									ExplorerPlugin
											.logError(
													"Exception occured on invocation of static method createInstance of the Target", e.getTargetException());//$NON-NLS-1$
								}
							} catch (IllegalAccessException e) {
								ExplorerPlugin
										.logError(
												"Target does not support static method createInstance", e);//$NON-NLS-1$
							} catch (PartInitException e) {
								ExplorerPlugin.logError(
										"Could not activate Editor", e);//$NON-NLS-1$
							}
						}
					}
				}
			}
		}

		return null;
	}
	/**
	 * Dispose of the Explorer widget
	 */
	public void dispose() {
		super.dispose();
		Ooaofooa.removeModelChangeListenerFromAll(m_modelChangeListener);
		TransactionManager.getSingleton().removeTransactionListener(
				m_transactionListener);
		selection.removeSelectionChangedListener(m_selChangedListener);
	}
	/**
	 * Initialize the Label provider to link it into the chain 
	 * of platform label decorators.
	 */
	protected void initLabelProvider(TreeViewer viewer) {
		viewer.setLabelProvider(new DecoratingLabelProvider(
				(ILabelProvider) viewer.getLabelProvider(), CorePlugin
						.getDefault().getWorkbench().getDecoratorManager()
						.getLabelDecorator()));
	}

	/**
	 * Sets whether this explorer's selection is linked to that of the 
	 * whichever editor is currently open.  This method is used by
	 * automated test programs to simulate pressing/unpressing the 
	 * "Link with Editor" button of the explorer.
	 */
	public void setLinkWithEditor(boolean link) {
		linkWithEditor.setChecked(link);
	}
	/**
	 * Has this explorer-view behave as if its open-action was just
	 * invoked.  Returns the editor that was opened.  For automated test purposes.
	 */
	public IEditorPart doOpen() {
		return handleOpen();
	}

	/**
	 * Has this explorer-view behave as if its delete-action was just
	 * invoked.  For automated test purposes.
	 */
	public void doDelete() {
		delete.run();
	}

	/**
	 * To disable or Enable rename and delete actions
	 * 
	 */
	private void keyActionsActivation() {
		IStructuredSelection structuredSelection = Selection.getInstance()
				.getStructuredSelection();
		Object context = structuredSelection.getFirstElement();
		if (context instanceof NonRootModelElement) {
			rename.setEnabled(RenameAction.canRenameAction());
		}
		boolean enableDel = false;
		IStructuredSelection selection = Selection.getInstance()
				.getStructuredSelection();
		if (!selection.isEmpty()) {
			enableDel = true;
			// Iterate through removing elements that are only graphical
			for (Iterator iter = selection.iterator(); iter.hasNext();) {
				Object current = iter.next();
				if (!(current instanceof NonRootModelElement)) {
					enableDel = false;
					break;
				}
			}

		}
		if (enableDel) {
			delete.setEnabled(DeleteAction.canDeleteAction());
		} else {
			delete.setEnabled(enableDel);
		}

	}
}
