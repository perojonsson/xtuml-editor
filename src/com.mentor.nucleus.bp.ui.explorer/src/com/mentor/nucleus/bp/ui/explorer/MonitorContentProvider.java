package com.mentor.nucleus.bp.ui.explorer;
//======================================================================
//
// File: com/mentor/nucleus/bp/ui/explorer/MonitorContentProvider.java
//
// WARNING:      Do not edit this generated file
// Generated by: arc/create_mon_content_provider.inc
// Version:      $Revision$
//
// (c) Copyright 2006-2014 , by Mentor Graphics Corp.  All rights reserved.
//
//======================================================================
//
// This class is an adapter that decouples the client model objects from
// the tree viewer by delegating the job of finding a parent of an element
// or the children of an element to the correct adapter.
//
import java.util.ArrayList;

import org.eclipse.jface.viewers.ITreeContentProvider;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;

import com.mentor.nucleus.bp.core.*;
import com.mentor.nucleus.bp.ui.explorer.adapters.*;

public class MonitorContentProvider implements ITreeContentProvider {
	protected TreeViewer viewer;
	/**
	 * @see IContentProvider#dispose()
	 */
	public void dispose() {
		// No resources allocated, nothing to dispose.
	}
	/**
	 * @see IContentProvider#inputChanged(Viewer, Object, Object)
	 */
	/**
	 * Notifies this content provider that the given viewer's input
	 * has been switched to a different element.
	 * <p>
	 * A typical use for this method is registering the content provider as a listener
	 * to changes on the new input (using model-specific means), and deregistering the viewer
	 * from the old input. In response to these change notifications, the content provider
	 * propagates the changes to the viewer.
	 * </p>
	 *
	 * @param viewer the viewer
	 * @param oldInput the old input element, or <code>null</code> if the viewer
	 *   did not previously have an input
	 * @param newInput the new input element, or <code>null</code> if the viewer
	 *   does not have an input
	 */
	public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
		// Singleton model, nothing to do
	}
	/**
	 * @see ITreeContentProvider#getChildren(Object)
	 */
	public Object[] getChildren(Object parentElement) {
		if (parentElement instanceof Ooaofooa) {
			ArrayList result = new ArrayList();
			Object[] systems = RootAdapter.getInstance().getChildren(
					parentElement);
			for (int i = 0; i < systems.length; i++) {
				if (systems[i] instanceof SystemModel_c) {
					Object[] uDoms = ((SystemModel_c) systems[i]).getChildren();
					Object[] fDoms = Domain_c
							.getManyS_DOMsOnR4204(DomainAsComponent_c.getManyCN_DCsOnR4204(Component_c.getManyC_CsOnR4604(ComponentPackage_c
									.getManyCP_CPsOnR4602((SystemModel_c) systems[i]))));
					Object[] doms = new Object[uDoms.length + fDoms.length];
					for (int j = 0; j < uDoms.length; j++) {
						doms[j] = uDoms[j];
					}
					for (int j = 0; j < fDoms.length; j++) {
						doms[uDoms.length + j] = fDoms[j];
					}
					for (int j = 0; j < doms.length; j++) {
						Domain_c dom = null;
						if (doms[j] instanceof Domain_c) {
							dom = (Domain_c) doms[j];
						}
						if (dom != null) {
							ComponentInstance_c[] engines = ComponentInstance_c
									.getManyI_EXEsOnR2948(dom);
							Component_c component = Component_c
									.getOneC_COnR4204(DomainAsComponent_c
											.getOneCN_DCOnR4204(dom));
							if (component != null) {
								engines = getEnginesForComponent(component);
							}
							for (int k = 0; k < engines.length; k++) {
								addTo(result, engines[k]);
							}
						}
					}
					Component_c[] gComps = Component_c
							.getManyC_CsOnR8001(PackageableElement_c.getManyPE_PEsOnR8000(Package_c
									.getManyEP_PKGsOnR1405((SystemModel_c) systems[i])));
					for (int j = 0; j < gComps.length; j++) {
						ComponentInstance_c[] engines = getEnginesForComponent(gComps[j]);
						for (int k = 0; k < engines.length; k++) {
							addTo(result, engines[k]);
						}
					}
				}
			}
			return result.toArray();
		}
		return null;
	}
	private void addTo(ArrayList result, ComponentInstance_c engine) {
	}
	private ComponentInstance_c[] getEnginesForComponent(Component_c componentC) {
		ComponentInstance_c[] compEngines = ComponentInstance_c
				.getManyI_EXEsOnR2955(componentC);
		ComponentInstance_c[] iCompEngines = ComponentInstance_c
				.getManyI_EXEsOnR2963(ComponentReference_c
						.getManyCL_ICsOnR4201(componentC));
		ComponentInstance_c[] engines = new ComponentInstance_c[compEngines.length
				+ iCompEngines.length];
		for (int k = 0; k < compEngines.length; k++) {
			engines[k] = compEngines[k];
		}
		for (int k = 0; k < iCompEngines.length; k++) {
			engines[compEngines.length + k] = iCompEngines[k];
		}
		return engines;
	}
	/**
	 * @see ITreeContentProvider#getParent(Object)
	 */
	public Object getParent(Object element) {
		if (element instanceof Ooaofooa) {
			return RootAdapter.getInstance().getParent(element);
		}
		return null;
	}
	/**
	 * @see ITreeContentProvider#hasChildren(Object)
	 */
	public boolean hasChildren(Object element) {
		if (element instanceof Ooaofooa) {
			return RootAdapter.getInstance().hasChildren(element);
		}
		// Unknown element
		return false;
	}
	/**
	 * @see IStructuredContentProvider#getElements(Object)
	 */
	public Object[] getElements(Object inputElement) {
		return getChildren(inputElement);
	}
}
