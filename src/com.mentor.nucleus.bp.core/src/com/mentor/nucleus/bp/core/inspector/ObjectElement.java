package com.mentor.nucleus.bp.core.inspector;
//======================================================================
//
// File: com/mentor/nucleus/bp/core/inspector/ObjectElement.java
//
// WARNING:      Do not edit this generated file
// Generated by: arc/create_model_inspector.arc
// Version:      $Revision$
//
// (c) Copyright 2004-2014 by Mentor Graphics Corp.  All rights reserved.
//
//======================================================================
//
// An ObjectElement represents a metamodel class attribute.  It allows
// access to it's name and value
//
import com.mentor.nucleus.bp.core.common.NonRootModelElement;

public class ObjectElement{
	public static final int ATTRIBUTE_ELEMENT = 0;
	public static final int REFERENTIAL_ATTRIBUTE_ELEMENT = 1;
	public static final int RELATION_ROLE_ELEMENT = 2;

	private String name;
	private int type;
	private Object value;
	private Object parent;
	private String valueAccessor;
	private boolean userModifiable;
	private Object owner;
	private boolean derived = false;
	
	public ObjectElement(String aName, int aType, Object aValue, Object parent, boolean userModifiable){
	    this(aName, aType, aValue, parent, "", userModifiable);
	}
	
	public ObjectElement(String aName, int aType, Object aValue, Object parent, String valueAccessor, boolean userModifiable){
		name = aName;
		
		if(aType < ATTRIBUTE_ELEMENT || aType > RELATION_ROLE_ELEMENT)
			throw new IllegalArgumentException("Invalid Type");
		
		type = aType;
		value = aValue;
		this.parent = parent;
		this.valueAccessor = valueAccessor;
		this.userModifiable = userModifiable;
	}

	public String getValueAccessor() {
	    return valueAccessor;
	}

	public String getName() {
		return name;
	}

	public int getType() {
		return type;
	}

	public Object getValue() {
		return value;
	}
	
	public boolean isUserModifiable() {
		return userModifiable;
	}
	
	public void setValue(Object newValue) {
		value = newValue;
	}
	
	public Object getParent() {
	    return parent;
	}
	
	public void setAttributeOwner(Object owner) {
		this.owner = owner;
	}
	
	public Object getAttributeOwner() {
		return owner;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof ObjectElement) {
			ObjectElement other = (ObjectElement) obj;
			if (identityEquals(getParent(), other.getParent())) {
				if (other.getType() == getType()
						&& other.getName().equals(getName())) {
					return true;
				}
			}
		}
		return false;
	}
	
	private boolean identityEquals(Object element1, Object element2) {
		NonRootModelElement nrme1 = (NonRootModelElement) element1;
		NonRootModelElement nrme2 = (NonRootModelElement) element2;
		if(nrme1 == nrme2) {
			return true;
		}
		if(nrme1.identityEquals(nrme2)) {
		  	return true;
		}
		if(handleProxyEquality(nrme1, nrme2)) {
			return true;
		}
		return false;
}

	private boolean handleProxyEquality(NonRootModelElement nrme1,
			NonRootModelElement nrme2) {
		return nrme1.cachedIdentityEquals(nrme2);
	}
	
	@Override
	public int hashCode() {
		int hash = 1;
		Object instanceKey = ((NonRootModelElement) getParent()).getInstanceKey();
		if(instanceKey instanceof Object[]) {
			for (int i = 0; i < ((Object[]) instanceKey).length; i++) {
				hash = hash + ((Object[]) instanceKey)[i].hashCode();
			}
		} else {
			hash = hash + instanceKey.hashCode();
		}
		hash = hash + 31 * getType();
		hash = hash + 31 * getName().hashCode();
		return hash;
	}
	
	/**
	 * setDerived does not take a parameter as the ObjectElement class can
	 * be either derived or non-derived, it will never change during its
	 * existence
	 */
	public void setDerived() {
		derived = true;
	}
	
	public boolean isDerived() {
	  	return derived;
	}
	
}
